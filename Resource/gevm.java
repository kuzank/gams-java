/*  Java code generated by apiwrapper for GAMS Version 30.1.0
 *
 * GAMS - Loading mechanism for GAMS Expert-Level APIs
 *
 * Copyright (c) 2016-2020 GAMS Software GmbH <support@gams.com>
 * Copyright (c) 2016-2020 GAMS Development Corp. <support@gams.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.gams.api;

import java.io.File;

public class gevm {
   public static final int gevdoErr  = 0; /* gevLogStatMode */
   public static final int gevdoStat = 1;
   public static final int gevdoLog  = 2;

   public static final int gevSolverSameStreams = 0; /* gevCallSolverMode */
   public static final int gevSolverQuiet       = 1;
   public static final int gevSolverOwnFile     = 2;

   public static final int gevSolveLinkCallScript    = 1; /* gevCallSolverSolveLink */
   public static final int gevSolveLinkCallModule    = 2;
   public static final int gevSolveLinkAsyncGrid     = 3;
   public static final int gevSolveLinkAsyncSimulate = 4;
   public static final int gevSolveLinkLoadLibrary   = 5;

   public static final String gevAlgFileType  = "AlgFileType"; /* gevOptions */
   public static final String gevGamsVersion  = "GamsVersion";
   public static final String gevLogOption    = "LogOption";
   public static final String gevReform       = "Reform";
   public static final String gevIDEFlag      = "IDEFlag";
   public static final String gevDomLim       = "DomLim";
   public static final String gevIterLim      = "IterLim";
   public static final String gevNodeLim      = "NodeLim";
   public static final String gevSysOut       = "SysOut";
   public static final String gevInteger1     = "Integer1";
   public static final String gevInteger2     = "Integer2";
   public static final String gevInteger3     = "Integer3";
   public static final String gevInteger4     = "Integer4";
   public static final String gevInteger5     = "Integer5";
   public static final String gevGenSolver    = "GenSolver";
   public static final String gevCurSolver    = "CurSolver";
   public static final String gevPageWidth    = "PageWidth";
   public static final String gevPageSize     = "PageSize";
   public static final String gevKeep         = "Keep";
   public static final String gevThreadsRaw   = "ThreadsRaw";
   public static final String gevFDOpt        = "FDOpt";
   public static final String gevOptCR        = "OptCR";
   public static final String gevOptCA        = "OptCA";
   public static final String gevResLim       = "ResLim";
   public static final String gevWorkSpace    = "WorkSpace";
   public static final String gevWorkFactor   = "WorkFactor";
   public static final String gevCutOff       = "CutOff";
   public static final String gevUseCutOff    = "UseCutOff";
   public static final String gevCheat        = "Cheat";
   public static final String gevUseCheat     = "UseCheat";
   public static final String gevTryInt       = "TryInt";
   public static final String gevReal1        = "Real1";
   public static final String gevReal2        = "Real2";
   public static final String gevReal3        = "Real3";
   public static final String gevReal4        = "Real4";
   public static final String gevReal5        = "Real5";
   public static final String gevHeapLimit    = "HeapLimit";
   public static final String gevFDDelta      = "FDDelta";
   public static final String gevNameCtrFile  = "NameCtrFile";
   public static final String gevNameLogFile  = "NameLogFile";
   public static final String gevNameStaFile  = "NameStaFile";
   public static final String gevNameScrDir   = "NameScrDir";
   public static final String gevNameGamsDate = "NameGamsDate";
   public static final String gevNameGamsTime = "NameGamsTime";
   public static final String gevNameSysDir   = "NameSysDir";
   public static final String gevNameWrkDir   = "NameWrkDir";
   public static final String gevNameCurDir   = "NameCurDir";
   public static final String gevLicense1     = "License1";
   public static final String gevLicense2     = "License2";
   public static final String gevLicense3     = "License3";
   public static final String gevLicense4     = "License4";
   public static final String gevLicense5     = "License5";
   public static final String gevLicense6     = "License6";
   public static final String gevNameMatrix   = "NameMatrix";
   public static final String gevNameInstr    = "NameInstr";
   public static final String gevNameParams   = "NameParams";
   public static final String gevNameScrExt   = "NameScrExt";
   public static final String gevNameScenFile = "NameScenFile";
   public static final String gevNameExtFFile = "NameExtFFile";

   private long gevPtr = 0;
   public native static int    GetReady (String[] msg);
   public native static int    GetReadyD(String dirName, String[] msg);
   public native static int    GetReadyL(String libName, String[] msg);
   public native int    Create   (String[] msg);
   public native int    CreateD  (String dirName, String[] msg);
   public native int    CreateDD (String dirName, String[] msg);
   public native int    CreateL  (String libName, String[] msg);
   public native int    Free     ();
   public native void    RegisterWriteCallback(String lsw, boolean logenabled, long usrmem);
   public native void    CompleteEnvironment(long palg, long ivec, long rvec, long svec);
   public native int    InitEnvironmentLegacy(String cntrfn);
   public native boolean    SwitchLogStat(int lo, String logfn, boolean logappend, String statfn, boolean statappend, String lsw, long usrmem, long []lshandle);
   public native long    GetLShandle();
   public native boolean    RestoreLogStat(long []lshandle);
   public native boolean    RestoreLogStatRewrite(long []lshandle);
   public native void    Log(String s);
   public native void    LogPChar(String p);
   public native void    Stat(String s);
   public native void    StatC(String s);
   public native void    StatPChar(String p);
   public native void    StatAudit(String s);
   public native void    StatCon();
   public native void    StatCoff();
   public native void    StatEOF();
   public native void    StatSysout();
   public native void    StatAddE(int mi, String s);
   public native void    StatAddV(int mj, String s);
   public native void    StatAddJ(int mi, int mj, String s);
   public native void    StatEject();
   public native void    StatEdit(char C);
   public native void    StatE(String s, int mi, String s2);
   public native void    StatV(String s, int mj, String s2);
   public native void    StatT();
   public native void    StatA(String s);
   public native void    StatB(String s);
   public native void    LogStat(String s);
   public native void    LogStatNoC(String s);
   public native void    LogStatPChar(String p);
   public native void    LogStatFlush();
   public native void    LSTAnchor(String s);
   public native int    StatAppend(String statfn, String []msg);
   public native void    MIPReport(long gmoptr, double fixobj, int fixiter, double agap, double rgap);
   public native int    GetSlvExeInfo(String solvername, String []exename);
   public native int    GetSlvLibInfo(String solvername, String []libname, String []prefix, int []ifversion);
   public native int    CapabilityCheck(int modeltype, String solvername, boolean []capable);
   public native int    SolverVisibility(String solvername, boolean []hidden, boolean []defaultok);
   public native int    NumSolvers();
   public native int    Solver2Id(String solvername);
   public native int    CallSolver(long gmoptr, String cntrfn, String solvername, int solvelink, int Logging, String logfn, String statfn, double reslim, int iterlim, int domlim, double optcr, double optca, long []jobhandle, String []msg);
   public native int    CallSolverHandleStatus(long jobhandle);
   public native int    CallSolverHandleDelete(long []jobhandle);
   public native int    CallSolverHandleCollect(long []jobhandle, long gmoptr);
   public native int    GetIntOpt(String optname);
   public native double    GetDblOpt(String optname);
   public native void    SetIntOpt(String optname, int ival);
   public native void    SetDblOpt(String optname, double rval);
   public native void    SetStrOpt(String optname, String sval);
   public native void    SynchronizeOpt(long optptr);
   public native double    TimeJNow();
   public native double    TimeDiff();
   public native double    TimeDiffStart();
   public native void    TimeSetStart();
   public native void    TerminateUninstall();
   public native void    TerminateInstall();
   public native void    TerminateSet(long intr, long ehdler);
   public native boolean    TerminateGet();
   public native void    TerminateClear();
   public native void    TerminateRaise();
   public native void    TerminateGetHandler(long []intr, long []ehdler);
   public native int    WriteModelInstance(String mifn, long gmoptr, int []nlcodelen);
   public native int    DuplicateScratchDir(String scrdir, String logfn, String []cntrfn);
   public native int    InitJacLegacy(long []evalptr, long gmoptr);
   public native void    SetColRowPermLegacy(long evalptr, int n, int []cgms2slv, int m, int []rgms2slv);
   public native void    SetJacPermLegacy(long evalptr, int njacs, int []jacs, int []jgms2slv);
   public native int    EvalNewPointLegacy(long evalptr, double []x);
   public native int    EvalJacLegacy(long evalptr, int si, double []x, double []f, double []jac, int []domviol, int []njacsupd);
   public native int    EvalJacLegacyX(long evalptr, int cnt, int []rowidx, double []x, double []fvec, double []jac, int []domviol, int []njacsupd);
   public native int    NextNLLegacy(long evalptr, int si);
   public native int    RowGms2SlvLegacy(long evalptr, int si);
   public native void    FreeJacLegacy(long []evalptr);
   public native long    GetALGX();
   public native void    SkipIOLegacySet(boolean x);
   public native int    Threads();
   public native double    NSolves();
   private native String    GetAnchor(String s, String []sst_result);
   public String    GetAnchor(String s) {
       String[] sst_result = new String[1];
       return    GetAnchor(s, sst_result);
   }
   private native String    GetSolver(int modeltype, String []sst_result);
   public String    GetSolver(int modeltype) {
       String[] sst_result = new String[1];
       return    GetSolver(modeltype, sst_result);
   }
   private native String    GetCurrentSolver(long gmoptr, String []sst_result);
   public String    GetCurrentSolver(long gmoptr) {
       String[] sst_result = new String[1];
       return    GetCurrentSolver(gmoptr, sst_result);
   }
   private native String    GetSolverDefault(int modeltype, String []sst_result);
   public String    GetSolverDefault(int modeltype) {
       String[] sst_result = new String[1];
       return    GetSolverDefault(modeltype, sst_result);
   }
   private native String    Id2Solver(int solverid, String []sst_result);
   public String    Id2Solver(int solverid) {
       String[] sst_result = new String[1];
       return    Id2Solver(solverid, sst_result);
   }
   private native String    CallSolverNextGridDir(String []sst_result);
   public String    CallSolverNextGridDir() {
       String[] sst_result = new String[1];
       return    CallSolverNextGridDir(sst_result);
   }
   private native String    GetStrOpt(String optname, String []sst_result);
   public String    GetStrOpt(String optname) {
       String[] sst_result = new String[1];
       return    GetStrOpt(optname, sst_result);
   }
   private native String    GetScratchName(String s, String []sst_result);
   public String    GetScratchName(String s) {
       String[] sst_result = new String[1];
       return    GetScratchName(s, sst_result);
   }
   public        long    GetgevPtr(){ return gevPtr;}
   public gevm () { }
   public gevm (long gevPtr) {
      this.gevPtr = gevPtr;
   }
   static {
      String stem = "gevmjni";
      String bitsuffix = "";
 
      if ( System.getProperty("os.arch").toLowerCase().indexOf("64") >= 0 ||
           System.getProperty("os.arch").toLowerCase().indexOf("sparcv9") >= 0 ) {
           bitsuffix = "64";
      }
 
      String os = System.getProperty("os.name").toLowerCase();
      String prefix = "";
      String suffix = "";
 
      if (os.indexOf("win") >=0) {
         suffix = ".dll";
      } else if (os.indexOf("mac") >= 0) {
          prefix = "lib";
          suffix = ".dylib";
      } else {
          prefix = "lib";
          suffix = ".so";
      }
 
      boolean loaded = false;
      try  {
           String libPath = System.getProperty("java.library.path");
           if (libPath != null) {
               for (String str : libPath.split(System.getProperty("path.separator")) ) {
                   File curPath = new File(str);
                   String fileName = curPath.getCanonicalPath() + File.separator + prefix + stem + bitsuffix + suffix;
                   if ( new File(fileName).exists() ) {
                       System.load(fileName);
                       loaded = true;
                       break;
                   }
                }
            }
       } catch (Exception e) {
           loaded = false;
       } catch (UnsatisfiedLinkError e1) {
           loaded = false;
       } finally {
            if (!loaded) {
                try  {
                   System.loadLibrary(stem + bitsuffix);
                } catch (UnsatisfiedLinkError e1) {
                    String libraryFullPath = null;
                    String classPath = null;
                    try {
                       String packageName = (Class.forName(gevm.class.getName()).getPackage().getName());
                       StringBuilder sb = new StringBuilder();
                       String[] bs = packageName.split("\\.");
                       for (String s : bs) {
                          sb.append(s);
                          sb.append("/");
                        }
                       sb.append(gevm.class.getSimpleName());
                       sb.append(".class");
                       ClassLoader cl = gevm.class.getClassLoader();
 
                       classPath = cl.getResource(sb.toString()).getPath();
                       sb.insert(0, "/");
                       classPath = classPath.substring(0, classPath.lastIndexOf(sb.toString()));
                       if (classPath.endsWith("!")) {
                          int index = classPath.lastIndexOf("/");
                          if (index >= 0)
                              classPath = classPath.substring(0, index);
                        }
                       if (classPath.indexOf("/") >= 0) {
                           classPath = classPath.substring(classPath.indexOf(":")+1,classPath.length());
                       }
 
                       libraryFullPath = classPath + "/" + prefix + stem + bitsuffix + suffix ;
                       java.io.File apath = new java.io.File(libraryFullPath);
                       libraryFullPath = java.net.URLDecoder.decode(apath.getAbsolutePath(), "UTF-8");
                    } catch (Exception e2) {
                          e2.printStackTrace();
                          e1.printStackTrace();
                          throw (e1);
                    } finally {
                         if (libraryFullPath == null)  {
                            e1.printStackTrace();
                            throw (e1);
                         }
                    }
 
                    try {
                        System.load(libraryFullPath);
                    } catch (UnsatisfiedLinkError e3) {
                        e3.printStackTrace();
                        throw (e3);
                    }
               }
           }
        }
     }
}
